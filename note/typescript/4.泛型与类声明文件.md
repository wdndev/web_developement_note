# 4.泛型与类声明文件

## 1.泛型

泛型允许我们在定义函数、类或接口时，**使用类型参数来表示未指定的类型**，这些参数在具体使用时，才被指定具体的类型，泛型能让同⼀段代码适用于多种类型,同时仍然保持类型的安全性。

举例：如下代码中 `<T>` 就是泛型，(不⼀定非叫 `T` )，设置泛型后即可在函数中使用 `T` 来表示该类型。

### 1.1 泛型函数

```typescript 
// 泛型函数
function logData<T>(data: T): T {
    console.log(data)
    return data
}
logData<number>(100)
logData<string>('hello')

// 泛型可以有多个
function logData<T, U>(data1: T, data2: U): T | U {
    console.log(data1, data2)
    return Date.now() % 2 ? data1 : data2
}
logData<number, string>(100, 'hello')
logData<string, boolean>('ok', false)
```


### 1.2 泛型约束

在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法。

```typescript 
function echoWithArr<T>(arg: T): T {
  console.log(arg.length)
  return arg
}

```


上例中，泛型 `T` 不一定包含属性 `length`，我们可以给他传入任意类型，当然有些不包括 `length` 属性，那样就会报错

```typescript 
// 泛型约束
interface LengthInterface {
    length: number
}

// 约束规则是：传入的类型T必须具有 length 属性
function logPerson<T extends LengthInterface>(data: T): void {
    console.log(data.length)
}

logPerson<string>('hello')
logPerson({length: 10})
logPerson([1, 2, 3])

// 报错：因为number不具备length属性
// logPerson<number>(100)
```


### 1.3 泛型类与接口

```typescript 
class Queue<T> {
  private data: T[] = [];
  push(item: T) {
    return this.data.push(item)
  }
  pop() {
    return this.data.shift()
  }
}
const queue = new Queue<number>()

queue.push(1)

const poped = queue.pop()

if (poped) {
  poped.toFixed()
}

```


在上述代码中存在一个问题，它允许你向队列中添加任何类型的数据，当然，当数据被弹出队列时，也可以是任意类型。在上面的示例中，看起来人们可以向队列中添加string 类型的数据，但是那么在使用的过程中，就会出现我们无法捕捉到的错误，

```typescript 
class Queue<T> {
  private data = [];
  push(item: T) {
    return this.data.push(item)
  }
  pop(): T {
    return this.data.shift()
  }
}
const queue = new Queue<number>()
```


泛型类

```typescript 
// 泛型类
TypeScript
class Person<T> {
    constructor(public name: string, public age: number, public extraInfo: T) {}
    speak() {
        console.log(`我叫${this.name}今年${this.age}岁了`)
        console.log(this.extraInfo)
    }
}

// 测试代码1
const p1 = new Person<number>("tom", 30, 250);

// 测试代码2
type JobInfo = {
    title: string;
    company: string;
}

const p2 = new Person<JobInfo>("tom", 30, { title: '研发总监', company: '发发发科技公司' });
```


泛型接口

```typescript 
// 泛型接口
interface PersonInterface<T> {
    name: string,
    age: number,
    extraInfo: T
}
let p1: PersonInterface<string>
let p2: PersonInterface<number>
p1 = { name: '张三', age: 18, extraInfo: '一个好人' }
p2 = { name: '李四', age: 18, extraInfo: 250 }
```


## 2.类型声明文件

### 2.1 声明文件

- [声明文件](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html "声明文件")
- [@types官方声明文件库](https://github.com/DefinitelyTyped/DefinitelyTyped/ "@types官方声明文件库")
- [@types搜索声明库](https://www.typescriptlang.org/dt/search/ "@types搜索声明库")

### 2.2 内置类型

- [内置类型](https://github.com/Microsoft/TypeScript/tree/master/src/lib "内置类型")

类型声明文件是 TypeScript 中的⼀种特殊文件，通常以 `.d.ts` 作为扩展名。它的主要作用是**为现有的JavaScript 代码提供类型信息**，使得 TypeScript 能够在使用这些 JavaScript 库或模块时进行**类型检查和提示**。

```typescript 
// demo.js
export function add(a, b) {
    return a + b;
}
export function mul(a, b) {
  return a * b;
}

// demo.d.ts
declare function add(a: number, b: number): number;
declare function mul(a: number, b: number): number;
export { add, mul };

// index.ts
// example.ts
import { add, mul } from "./demo.js";

const x = add(2, 3); // x 类型为 number
const y = mul(4, 5); // y 类型为 number

console.log(x, y);
```
