# 3.类与接口

## 1. 复习类相关知识

本小节是复习类相关知识,如果有相关基础可以跳过。

类 class

```typescript 
class Person {
  // 属性声明
  name: string;
  age: number;
  
  // 构造器
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
  
  // 方法
  speak() {
    console.log(`我叫: ${this.name}, 今年${this.age}岁`);
  }
}

// Person实例
const p1 = new Person('周杰伦', 38);
```


Student 继承 Person

```typescript 
class Student extends Person {
  grade: string;
  
  // 构造器
  constructor(name: string, age: number, grade: string) {
    super(name, age);
    this.grade = grade;
  }
  // 备注本例中若Student类不需要额外的属性，Student的构造器可以省略
  // 重写从父类继承的方法
  override speak() {
    console.log(`我是学生，我叫: ${this.name}，今年${this.age}岁，在读${this.grade}年级`);
  }
  
  // 子类自己的方法
  study() {
    console.log(`${this.name}正在努力学习中......`);
  }
}
```


## 2.属性修饰符

| 修饰符       | 含义   | 具体规则                      |
| --------- | ---- | ------------------------- |
| public    | 公开的  | 可以被：\*\*类内部、子类、类外部\*\*访问。 |
| protected | 受保护的 | 可以被：\*\* 类内部、子类\*\*访问。    |
| private   | 私有的  | 可以被：\*\*类内部\*\*访问。        |
| readonly  | 只读属性 | 属性无法修改。                   |

### 2.1 public 修饰符

Person 类

```typescript 
class Person {
  // name写了public修饰符，age没写修饰符，最终都是public修饰符
  public name: string;
  age: number;
  
  constructor(name: string, age: number) {
  this.name = name;
  this.age = age;
  }
  
  speak() {
  // 类的内部可以访问public修饰的name和age
  console.log(`我叫: ${this.name}, 今年${this.age}岁`);
  }
}

const p1 = new Person('张三', 18);
// 类的外部可以访问public修饰的属性
console.log(p1.name);
```


Student 继承 Person

```typescript 
class Student extends Person {
  constructor(name: string, age: number) {
  super(name, age);
  }
  
  study() {
  // 【子类中】可以访问父类中public修饰的：name属性、age属性
  console.log(`${this.age}岁的${this.name}正在努力学习`);
  }
}
```


属性的简写形式

完整写法

```typescript 
class Person {
    public name: string;
    public age: number;
​
    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }
}
```


简写形式

```typescript 
class Person {
    constructor(public name: string, public age: number) { }
}
```


### 2.2 protected 修饰符

Person类

```typescript 
class Person {
    // name和age是受保护属性，不能在类外部访问，但可以在类与子类中访问
    protected name: string;
    protected age: number;

    constructor(protected name: string, protected age: number) { }

    // getDetails是受保护方法，不能在类外部访问，但可以在类与子类中访问
    protected getDetails(): string {
        // 类中能访问受保护的name和age属性
        return `我叫: ${this.name}, 年龄是: ${this.age}`;
    }

    // introduce是公开方法，类、子类、类外部都能使用
    introduce() {
        // 类中能访问受保护的getDetails方法
        console.log(this.getDetails());
    }
}

const p1 = new Person('杨超越', 18);
// 可以在类外部访问introduce
p1.introduce();

// 以下代码均报错
// p1.getDetails();
// p1.name;
// p1.age;
```


Student 继承 Person

```typescript 
class Student extends Person {
    constructor(name: string, age: number) {
        super(name, age);
    }

    study() {
        // 子类中可以访问introduce
        this.introduce();
        // 子类中可以访问name
        console.log(`${this.name}正在努力学习`);
    }
}

const s1 = new Student('tom', 17);
s1.introduce();
```


### 2.3 private 修饰符

```typescript 
class Person {
  constructor(
  public name: string,
  public age: number,
  // IDCard属性为私有的(private)属性，只能在类内部使用
  private IDCard: string
  ) {}
  ​
  private getPrivateInfo() {
  // 类内部可以访问私有的(private)属性-IDCard
  return `身份证号码为: ${this.IDCard}`
  }
  ​
  getInfo() {
  // 类内部可以访问受保护的(protected)属性name和age
  return `我叫: ${this.name}，今年刚满${this.age}岁`;
  }
  ​
  getFullInfo() {
  // 类内部可以访问公开的getInfo方法，也可以访问私有的getPrivateInfo方法
  return this.getInfo() + ',' + this.getPrivateInfo();
  }
}
​
const p1 = new Person('张三', 18, '110114198702034432');
console.log(p1.getFullInfo());
console.log(p1.getInfo());
​
// 以下代码均报错
// p1.name
// p1.age
// p1.IDCard
// p1.getPrivateInfo()

```


### 2.4 readonly 修饰符

```typescript 
class Car {
   constructor(
     public readonly vin: string, //⻋辆识别码,为只读属性
     public readonly year: number,//出⼚年份,为只读属性
     public color: string,
     public sound: string
 ) { }
 // 打印⻋辆信息
 displayInfo() {
   console.log(`
   识别码:${this.vin},
   出⼚年份:${this.year},
   颜⾊:${this.color},
   ⾳响:${this.sound}
 `);
 }
}

const car = new Car('1HGCM82633A123456', 2018, '⿊⾊', 'Bose⾳响');
car.displayInfo()

// 以下代码均错误:不能修改 readonly 属性
// car.vin = '897WYE87HA8SGDD8SDGHF'; 
// car.year = 2020;
```


## 3.抽象类

- 概述：抽象类是⼀种\*\*⽆法被实例化的类\*\*，专门用来定义类的结构和行为，类中可以写抽象方法，也可以写具体实现。抽象类主要用来为其派生类提供⼀个基础结构，要求其派生类  必须实现其中的抽象方法。
- 简记：抽象类**不能实例化**，其意义是**可以被继承**，抽象类里可以有**普通方法**、也可以有**抽象方法**。

##### 通过以下场景,理解抽象类:

我们定义⼀个抽象类 `Package` ，表示所有包裹的基本结构，任何包裹都有重量属性 `weight` , 包裹都需要计算运费。但不同类型的包裹(如:标准速度、特快专递)都有不同的运费计算方式，因此用于计算运费的 `calculate` 方法是⼀个抽象方法，必须由具体的子类来实现。

- `Package` 类

```typescript 
abstract class Package {
    constructor(public weight: number){} 
    
    // 抽象⽅法:⽤来计算运费,不同类型包裹有不同的计算⽅式
    abstract calculate(): number // 通⽤⽅法:打印包裹详情
    
    printPackage() {
        console.log(`包裹重量为: ${this.weight}kg,运费为: ${this.calculate()}元`);
    }
}
```


- `StandardPackage` 类继承了 `Package` ,实现了 `calculate` ⽅法:

```typescript 
// 标准包裹
class StandardPackage extends Package {
    constructor( weight: number,
    public unitPrice: number // 每公⽄的固定费率 
  ) { super(weight) }
  
  // 实现抽象⽅法:计算运费
  calculate(): number {
    return this.weight * this.unitPrice;
  } 
}

// 创建标准包裹实例
const s1 = new StandardPackage(10,5)
s1.printPackage()
```


`ExpressPackage` 类继承了 `Package` ,实现了 `calculate` ⽅法:

- `ExpressPackage` 类(特快包裹)

```typescript 
class ExpressPackage extends Package {
  constructor(
    private weight: number, // 每公⽄的固定费率(快速包裹更⾼)
    private unitPrice: number,  
    private additional: number // 超出10kg以后的附加费
  ){ super(weight) }
  
   // 实现抽象⽅法:计算运费
   calculate(): number {
     if(this.weight > 10){
     // 超出10kg的部分,每公⽄多收additional对应的价格
     return 10 * this.unitPrice + (this.weight - 10) * this.additional
     }else {
     return this.weight * this.unitPrice;
     }
   }
}
// 创建特快包裹实例
const e1 = new ExpressPackage(13,8,2)
e1.printPackage()
```


&#x20;总结：何时使用抽象类?

1. **定义通用接口**：为⼀组相关的类定义通用的行为(方法或属性)时。
2. **提供基础实现**：在抽象类中提供某些方法或为其提供基础实现，这样派生类就可以继承这些实现。
3. **确保关键实现**：强制派生类实现⼀些关键行为。
4. **共享代码和逻辑**：当多个类需要共享部分代码时，抽象类可以避免代码重复。

## 4.interface(接口)

interface 是⼀种`定义结构`的方式，主要作用是为：类、对象、函数等规定`⼀种契约`，这样可以确保代码的⼀致性和类型安全，但要注意 interface `只能`定义`格式`,`不能`包含`任何实现` !

### 4.1 定义类结构

```typescript 
// PersonInterface接口，用与限制Person类的格式
interface PersonInterface {
    name: string;
    age: number;
    speak(n: number): void;
}

// 定义一个类Person，实现 PersonInterface 接口
class Person implements PersonInterface {
    constructor(
        public name: string,
        public age: number
    ) { }

    // 实现接口中的 speak 方法
    speak(n: number): void {
        for (let i = 0; i < n; i++) {
            // 打印出包含名字和年龄的问候语句
            console.log(`你好，我叫${this.name}，我的年龄是${this.age}`);
        }
    }
}

// 创建一个 Person 类的实例 p1，传入名字 'tom' 和年龄 18
const p1 = new Person('tom', 18);
p1.speak(3);
```


### 4.2 定义对象结构

```typescript 
interface UserInterface {
    name: string;
    readonly gender: string; // 只读属性
    age?: number; // 可选属性
    run: (n: number) => void;
}

const user: UserInterface = {
    name: "张三",
    gender: '男',
    age: 18,
    run(n) {
        console.log(`奔跑了${n}米`);
    }
};
```


### 4.3 定义函数结构

```typescript 
// 定义函数结构
interface CountInterface {
    (a: number, b: number): number;
}

const count: CountInterface = (x, y) => {
    return x + y;
}
```


```typescript 
const add = (x: number, y: number, z?: number):  number => {
    if (typeof z === 'number') {
        return x + y + z;
    } else {
        return x + y;
    }
};

interface ISum {
    (x: number, y: number, z?: number): number
}

let add2: ISum = add

console.log(add2(1, 2, 3))
```


### 4.4 接口之间的继承

一个 interface 继承另一个 interface，从而实现代码的复用

```typescript 
interface PersonInterface {
    name: string; // 姓名
    age: number; // 年龄
}

interface StudentInterface extends PersonInterface {
    grade: string; // 年级
}

const stu: StudentInterface = {
    name: "张三",
    age: 25,
    grade: '高三'
}
```


### 4.5 接口自动合井（可重复定义）

```typescript 
// PersonInterface接口
interface PersonInterface {
  // 属性声明
  name: string;
  age: number;
}
​
// 给PersonInterface接口添加新属性
interface PersonInterface {
  // 方法声明
  speak(): void;
}
​
// Person类实现PersonInterface
class Person implements PersonInterface {
  name: string;
  age: number;
  ​
  // 构造器
  constructor(name: string, age: number) {
  this.name = name;
  this.age = age;
  }
  ​
  // 方法
  speak() {
  console.log('你好!我是老师:', this.name);
  }
}
```


### 4.6 总结:何时使用接口?

1. **定义对象的格式**：描述数据模型、API 响应格式、配置对象........等等,是开发中⽤的最多 的场景。
2. **类的契约**：规定⼀个类需要实现哪些属性和方法。
3. **扩展已有接口**：⼀般用于扩展第三方库的类型, 这种特性在大型项目中可能会用到。

## 5.一些相似概念的区别

### 5.1 interface 与 type 的区别

相同点:&#x20;

- `interface` 和 `type` 都可用于于定义**对象结构**，在定义对象结构时两者可以互换。

不同点:

- `interface`：更专注于定义**对象和类**的结构，⽀持继承、合并。
- `type`：可以定义**类型别名、联合类型、交叉类型**，但不⽀持继承和⾃动合并。

`interface `和 `type `都可以定义对象结构

```typescript 
// 使⽤ interface 定义 Person 对象
interface PersonInterface {
  name: string;
  age: number;
  speak(): void;
}
// 使⽤ type 定义 Person 对象
type PersonType = {
  name: string;
  age: number;
  speak(): void;
};
// 使⽤PersonInterface
/* let person: PersonInterface = {
 name:'张三',
 age:18,
 speak(){
 console.log(`我叫:${this.name},年龄:${this.age}`)
 }
} */
// 使⽤PersonType
let person: PersonType = {
  name:'张三',
  age:18,
  speak(){
  console.log(`我叫:${this.name},年龄:${this.age}`)
 }
}
```


`interface `可以继承、合并

```typescript 
interface PersonInterface {
  name: string; // 姓名
  age: number; // 年龄
}
​
interface PersonInterface {
  speak: () => void;
}
​
interface StudentInterface extends PersonInterface {
  grade: string; // 年级
}
​
const student: StudentInterface = {
  name: '李四',
  age: 18,
  grade: '高二',
  speak() { console.log(this.name, this.age, this.grade); }
}
```


`type `的交叉类型

```typescript 
// 使⽤ type 定义 Person 类型,并通过交叉类型实现属性的合并
type PersonType = {
  name: string; // 姓名
  age: number; // 年龄
  } & {
  speak: () => void;
};

// 使⽤ type 定义 Student 类型,并通过交叉类型继承 PersonType
type StudentType = PersonType & {
  grade: string; // 年级
};
const student: StudentType = {
  name: '李四',
  age: 18,
  grade: '⾼⼆',
  speak() {
  console.log(this.name, this.age, this.grade);
  }
};
```


### 5.2 interface 与 抽象类的区别

相同点:

- 都能定义⼀个**类的格式**(定义类应遵循的契约)

不相同:

- 接口：只能**描述结构,不能有任何实现代码**,**⼀个类可以实现多个接⼝**。
- 抽象类：既可以包含抽象⽅法,也可以包含具体方法, **⼀个类只能继承⼀个抽象类**。

⼀个类可以实现多个接口

```typescript 
// FlyInterface 接⼝
interface FlyInterface {
  fly(): void;
}
// 定义 SwimInterface 接⼝
interface SwimInterface {
  swim(): void;
}
// Duck 类实现了 FlyInterface 和 SwimInterface 两个接⼝
class Duck implements FlyInterface, SwimInterface {
  fly(): void {
  console.log('鸭⼦可以⻜');
  }
  swim(): void {
  console.log('鸭⼦可以游泳');
  }
}

// 创建⼀个 Duck 实例
const duck = new Duck();
duck.fly(); // 输出: 鸭⼦可以⻜
duck.swim(); // 输出: 鸭⼦可以游泳
```
